{"pages":[{"title":"About","text":"Hi, this is Leyi Qiang. ContactGithub: https://github.com/leyiqiangWeChat: EzioAFEmail: leyiqiang@gmail.com","link":"/leyiqiang/about/index.html"},{"title":"","text":"","link":"/leyiqiang/categories/index.html"},{"title":"","text":"","link":"/leyiqiang/tags/index.html"}],"posts":[{"title":"Password-Based Authentications: Lamport&#39;s Hash","text":"IntroSuppose A wants to log into a server B, and A’s work station has no user specific configurations(e.g. CAs or private keys). Here are several ways A can use a password to authenticate to server: Send password directly to B (vulnerable to eavesdropping and impersonating) Diffie-Hellman key establishment(vulnerable to impersonating) SSL (need trust configuration and certificates) Use A’s hash(password) as a secret key:B-&gt;A: RA-&gt;B: hash(pwd, R)(vulnerable to dictionary attack) Use one time password scheme like Lamport’s Hash Use Strong password protocol Lamport’s HashImplementationsA-&gt;B: AB-&gt;A: n(a reasonably large number)B: Computes xn=hashn(password)A-&gt;B: xn-1=hashn-1(password)B: Computes xn‘ = hash(xn-1)B then compares xn‘ and xn, if they match, B consider the response is valid, then replace n to n-1 Advantages Prevents Eavesdropping attack If attacker compromises B, it cannot find the pre image of A’s password. Problems If n get to 1, A needs to set its password again with B. This process is vulnerable to Man in the Middle Attack(Small N attack): A sends B A B sends A n. T intercepts it and replaces n to n’ = n-10 A computes h = hashn-11(password). T intercepts it and replace h to h’ = hashn-1(password) = hash10(h) B hashes h’ once, get the match. A possible solution to this is for A to remember the approximate value of n, and do some sanity check for n. Now T can calculate the next 10 hashes that matches B’s expectations.This allows T login as A multiple times. When n drops to 1, A have to change its password for security issue(Enhancement: using salt–hash(password|salt)) Time complexity Human and PaperNote that Lamport’s Hash can be used in environments that workstation do not have the hash. We call this Human and Paper environment(vs. Workstation environment).The way it works is that the values hashi(password) will be pre-computed for all i in n. Then printed these hashes on a paper and give it to A. A crosses out hashes whenever it uses that hash to log in. Next time A will use the next value to login.","link":"/leyiqiang/2018/10/09/Lamport-s-Hash/"},{"title":"Useful Reading Materials","text":"Listed below are some interesting reading materials. Artificial Intelligence 100 Days Of ML Code 2018/2019/校招/春招/秋招/算法/机器学习(Machine Learning)/深度学习(Deep Learning)/自然语言处理(NLP)/C/C++/Python/面试笔记 Repository to track the progress in Natural Language Processing (NLP) 21个项目玩转深度学习———基于TensorFlow的实践详解 Simple and ready-to-use tutorials for TensorFlow Documentations &amp; Best Practices You Don’t Know JS You Don’t Need – People choose popular projects, often not because it applies to their problems. RESTful API 设计规范 33 concepts every JavaScript developer should know. Algorithnms 后端架构师技术图谱 Javascript Algorithms Python Algorithms Awesome Algorithms Resources Awesome Hacking Resources Awesome VS Code Papers With Code Awesome React Other Fun Stuff English Tips For Chinese Use Vue, Vuex, Immutable to code Tetris I’ll keep updating this(hopefully).— Date Modified: 2018-10-22 —","link":"/leyiqiang/2018/10/10/reading-materials/"},{"title":"Hexo Asset Folders","text":"In root’s _config.yml, set post_asset_folder to true: 1post_asset_folder: true When you create a new post, hexo will generate an asset folder with the same name as the post. To include assets in markdown: 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} Examples: 12{% asset_img example.jpg This is an example image %}{% asset_img &quot;spaced asset.jpg&quot; &quot;spaced title&quot; %}","link":"/leyiqiang/2018/10/15/Hexo-Asset-Folders/"},{"title":"Fighting the Landlord AI","text":"Fighting the Landlord AI 基于Minimax和MCTS的两种斗地主算法","link":"/leyiqiang/2019/05/15/Fighting-the-Landlord-AI/"},{"title":"Password-Based Authentications: Strong Password-Based Protocol","text":"Previous posts: The TESLA Broadcast Authentication Protocol, Lamport's Hash RequirementsA Strong Password-Based Protocols should have these requirements: Prevent attackers to eavesdrop the conversation on an authentication exchange Prevent attackers to obtain any information by impersonating either endpoint Prevent attackers to do off-line attack * Attackers should not be able to obtain any further information from observing any number of legitimate exchanges Ensure forward secrecy * An attacker impersonating either endpoint will be able to do a single or small amount of on-line password guess, which is unavoidable. However, multiple guesses should generate alarms to the server. Strong Password ProtocolsEncrypted Key Exchange (EKE)This is the basic form of strong password protocol. Premise:A has a weak password (i.e. A and B share a weak secret W derived from password, usually hash(password)). Approach:A -&gt; B: W{ga mod p}B -&gt; A: W{gb mod p}, c1The key K establishment is based on Diffie-Hellman exchange, so K = gab mod pA -&gt; B: K{c1, c2}B -&gt; A: K{c2 - 1}The last two steps is to authenticate between A and B by providing challenges c1 and c2. Does it prevent off-line attack?Yes. T can only get Diffle-Hellman messages from off-line guessing, which is impossible to derive K. Also, W{ga mode p} is just a random number. For any password W’ there exist an r such that W’{r} = W{ga mod p} How about Forward Secrecy?It ensures forward secrecy. a, b, K are only used in this session and will be forgotten later on. If T compromises K, T will not be able to get further information in latter communication.The only information that will not be forgotten is W. However, T still cannot get K with W.(Unless A or B get compromised and a, b is known by T). Simple Password Expotential Key Exchange (SPEKE)Approach:It uses W in place of g in the Diffle-Hellman exchange: A -&gt; B: wa mod pB -&gt; A: wb mod p Where K = wab mod p Password Derived Moduli (PDM)Approach:It uses a modulus p which is a function of the password. And uses 2 as the base: A -&gt; B: 2a mod pB -&gt; A: 2a mod p Where K = 2ab mod p Flaws and AttacksIn EKEIf p is only a little more than a power of 2, for example, p = 2k+i for small i.Since ga mod p &lt; p. A eavesdropper can try guessing the password, if the password is correct, the result will definitely less than p, if it is not correct, the result will fall randomly between [0, 2k+1-1]([0, p+p-1]). The attacker will know the result is incorrect if it is larger than p.The changes of getting a correctly password will be (2k+i)/2b, which is almost 50%.To eliminate this flaw, we need to choose a p which is a little less than a power of 2. In SPEKEThe eavesdropper might be able to eliminate some pasword guesses based on seeing wa mod p. If some of the Ws generated from passwords for use in SPEKE were perfect squares and some not, then if wa mod p was not a perfect square, the attacker could know none of passwords resulted in Ws that were perfect square could have been A’s password.To check if a number w=x2 mod p is a perfect square mod p, we can do w(p-1)/2 mod p. If the result is 1 mod p, then it is a perfect square. To eliminate this problem, we simply need to ensure every w is a perfect square mod p. Augmented Strong Password ProtocolsGoal: If an attacker T compromises B, T cannot succeed with an offline attack Approach: Avoiding storing W in B’s database but only something derived from W. Requirement: The password must be strong so that the off-line attack will not succeed. Augmented PDM B stores A, p, 2w mod p (p is derived from password) A -&gt; B: 2a mod p B -&gt; A: 2b mod p, hash(2ab mod p, 2bw mod p) A -&gt; B: hash’(2ab mod p, 2bw mod p) (this hash’ is for B to authenticate A) Note that it is not possible for attacker T to do this:T impersonate A, sends 2k mod p to B. T gets 2b mod p and hash(2kb mod p, 2bw mod p) from B, then do offline attacks by trying different w. Because p is derived from password, so B will recognize it’s not a valid message. Augmentation Based on RSA Public Keys B stores A, W, {A}(A’s public key), Y=W’{[A]}(A’s private key) A -&gt; B: A, W{ga mod p} B choose b and challenge c B -&gt; A: W{gb mod p}, ((gab mod p)){Y} A -&gt; B: [hash(gab mod p, c)]sign-A Note that if T breaks into B, T can get W, but T cannot get W’ Secure Remote Password (SRP) B stores A, gw mod p A choose a, compute W from password A -&gt; B: A, ga mod p B choose b, c1 and a 32-bit number u B sends gb+gw mod p, u, c1(K = gb(a+uW) mod p) A -&gt; B: K{c1}, c2 B -&gt; A: K{c2} ** How is the common key computed on both ends? **For A: gb+gw mod p - gw mod p = gbThen (gb)(a+uw) mod pFor B: (ga)b*(gw)bu mod p","link":"/leyiqiang/2018/10/12/strong-password-protocol/"},{"title":"Set modules to false in babel","text":"Version 2 of webpack supports ES6 modules syntax natively, meaning you can use import and export without a tool like babel to handle this for you. So when we config babel-preset-env we can set “modules” to false, instead of using babel to compiling then into other module type.","link":"/leyiqiang/2019/05/22/Set-modules-to-false-in-babel/"},{"title":"Padding Oracle Attack","text":"RequirementThe system must use CBC mode with PKCS7 for the padding block. This is a chosen-ciphertext attack, The adversary can submit encrypted messages to the system, and the system will return valid or invalid as response. Assume block size is 8. Background Encryption Decryption Ci = Encrypt(Pi ⊕ Ci-1) Pi = Decrypt(Ci ⊕ Ci-1) Steps For each block C[i], the attacker creates C’: 1C' = C[i-1] ⊕ 0xX ⊕ 0x01 where X is a guessed byte. The attacker then submits (IV, C’ + C[i]) to the Oracle. Then the oracle will decrypt this message: 123Pi’ = Decrypt(C[i]) ⊕ C' = Decrypt(C2[i]) ⊕ C2[i-1] ⊕ 00…000X ⊕ 00…0001 = Pi ⊕ 00…000X ⊕ 00…0001 If the last byte of Pi = X, then the last byte of Pi’ will be 01, and Oracle will indicate this message is valid. Otherwise Oracle will return invalid because the number doesn’t match padding length. The attacker can just iterate all the possible bytes of X (256 possibilities) and find the one that returns valid. Then, to guess the last second byte, attacker can submit 1C' = C2[i-1] ⊕ 00…00YX ⊕ 00…0202 where Y is the guessed byte. The attacker can do the same thing again and again until all the bytes of this block is guessed correctly. Protection Use MAC for integrity protection Re-implement the system so that it won’t return any useful information to the attacker","link":"/leyiqiang/2018/10/18/padding-oracle-attack/"},{"title":"CPP Best Practices and Notes","text":"Notes taken from https://www.learncpp.com/ 9.2 Arrays II Explicitly initialize arrays, even if they would be initialized without an initializer list. When passing arrays to functions, C++ does not copy an array. The actual array is passed. To ensure a function does not modify the array passed into it, make the array const:123void functionWithArray(const int arr[5]) { std::size(arr); // note that this will cause error!! When you are in the same function that a array isdeclared in, sizeof() will return the total size of the array (array length multiplied by element size) When sizeof is used on an array that has been passed to a function, it doesn’t errorout like std::size() does. Instead, it returns the size of a pointer. 9.6 C Style Strings Don’t use C-style strings! Use std::string or std::string_view instead. 9.7 std::string_view-Unlike std::string, which keeps its own copy of the string, std::string_view provides a view of a string that is defined elsewhere.-Prefer std::string_view over std::string for read-only strings, unless you already have a std::string.","link":"/leyiqiang/2021/06/16/CPP-Best-Practices-and-Notes/"},{"title":"babel-polyfill and babel-runtime","text":"Use @babel/runtime when you don’t want to pollute global namespace(e.g. you are building a library). Install @babel/plugin-transform-runtime as development dependency. 1npm install --save-dev @babel/plugin-transform-runtime Install @babel/runtime as a production dependency. 1npm install --save @babel/runtime Use @babel/polyfill for writing an app. Source: https://babeljs.io/docs/en/babel-plugin-transform-runtime","link":"/leyiqiang/2018/10/14/babel-polyfill-and-babel-runtime/"},{"title":"NodeJS poll phrase blocking logic","text":"As mentioned in the NodeJS doc, in poll phrase, node will block when appropriate. This post will discuss the block conditions and why this phrase blocks as Node should perfom a non-blocking I/O operations. There are several logics in libuv core.c First is the uv_run function, which operates the process of entire event loop: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int uv_run(uv_loop_t* loop, uv_run_mode mode) { int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) { uv__update_time(loop); uv__run_timers(loop); ran_pending = uv__run_pending(loop); uv__run_idle(loop); uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout); uv__run_check(loop); uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) { /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); } r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; } /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;} uv__io_poll takes timeout as the second argument. When the event loop runs UV_RUN_DEFAULT mode or runs under UV_RUN_ONCE mode with no pending query, timeout will be calculated with uv_backend_timeout function.Otherwise it is set to 0.Here’s the uv_backend_timeout code: 123456789101112131415161718int uv_backend_timeout(const uv_loop_t* loop) { if (loop-&gt;stop_flag != 0) return 0; if (!uv__has_active_handles(loop) &amp;&amp; !uv__has_active_reqs(loop)) return 0; if (!QUEUE_EMPTY(&amp;loop-&gt;idle_handles)) return 0; if (!QUEUE_EMPTY(&amp;loop-&gt;pending_queue)) return 0; if (loop-&gt;closing_handles) return 0; return uv__next_timeout(loop);} (loop-&gt;stop_flag determines whether the event loop is about to exit.) Here’s the uv__next_timeout code: 12345678910111213141516171819int uv__next_timeout(const uv_loop_t* loop) { const struct heap_node* heap_node; const uv_timer_t* handle; uint64_t diff; heap_node = heap_min(timer_heap(loop)); if (heap_node == NULL) return -1; /* block indefinitely */ handle = container_of(heap_node, uv_timer_t, heap_node); if (handle-&gt;timeout &lt;= loop-&gt;time) return 0; diff = handle-&gt;timeout - loop-&gt;time; if (diff &gt; INT_MAX) diff = INT_MAX; return (int) diff;} Timers are stored in heap, if timer stack is empty, it will block indefinitely.Otherwise it returns the closest timer, which means that the loop will only be blocked when there are no pending tasks to do and it will wait until the next timeout.","link":"/leyiqiang/2019/05/18/nodeJS-poll-phrase-blocking-logic/"},{"title":"Password-Based Authentications: The Broadcast Authentication Protocol","text":"Previous post: Lamport's Hash. Approach Sender A splits time into intervals of equal duration I. A forms a one-way chain of self-authenticating values Xn, assign the values sequentially. The one-way chain is used in the reverse order of generation, so any value of a time interval can be used to derive values of previous time intervals. A defines a disclosure time for one-way chain values. A will publish the value after the disclosure time. For example, on time interval i, A publish Xn-(i-1). A attaches MAC to each packet, and use the key on that time interval to compute MAC: MAC(Mi, Xn-i)(on time i). A also sends the value it can disclose. When B receives the packet, it checks that A has not disclose the value X to make sure the key is still secret. Then B buffers the packet. B also checks the disclosed value is correct and verify MAC of this packet(base on time interval). If MAC is correct. B accept the packet. One-Way Chains Any value of a time interval can be used to derive values of previous time intervals.So even if some disclosed keys are lost, B can still recover the key chain. Requirements Receivers should be loosely time synchronized with the sender. Either receiver or senders must buffer some messages. Advantages Low communication overhead (and for generation and verification of authentication information) Limited buffering required for the sender and the receiver, hence timely authentication for each individual packet Robustness to packet loss Scales to a large number of receivers Low authentication delay Source: The TESLA Broadcast Authentication Protocol","link":"/leyiqiang/2018/10/11/broadcast-authentication-protocol/"}],"tags":[{"name":"Network Security","slug":"Network-Security","link":"/leyiqiang/tags/Network-Security/"},{"name":"Authentication Protocols","slug":"Authentication-Protocols","link":"/leyiqiang/tags/Authentication-Protocols/"},{"name":"Readings","slug":"Readings","link":"/leyiqiang/tags/Readings/"},{"name":"Web Development","slug":"Web-Development","link":"/leyiqiang/tags/Web-Development/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","link":"/leyiqiang/tags/Artificial-Intelligence/"},{"name":"Algorithms","slug":"Algorithms","link":"/leyiqiang/tags/Algorithms/"},{"name":"Babel","slug":"Babel","link":"/leyiqiang/tags/Babel/"},{"name":"CPP","slug":"CPP","link":"/leyiqiang/tags/CPP/"},{"name":"nodeJS","slug":"nodeJS","link":"/leyiqiang/tags/nodeJS/"}],"categories":[{"name":"Learning Notes","slug":"Learning-Notes","link":"/leyiqiang/categories/Learning-Notes/"},{"name":"Dev Notes","slug":"Dev-Notes","link":"/leyiqiang/categories/Dev-Notes/"}]}